# 209 长度最小的子数组

## 题目

难度：中等

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其和 `≥ target` 的长度最小的 连续子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

``` bash
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

示例 2：

``` bash
输入：target = 4, nums = [1,4,4]
输出：1
```

示例 3：

``` bash
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

提示：

* `1 <= target <= 109`
* `1 <= nums.length <= 105`
* `1 <= nums[i] <= 105`

进阶：

如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## 思路

### 1. 暴力破解

时间复杂度为 O(n^2)，需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标
空间复杂度为 O(1)
此解法在 LeetCode 上已经超时

``` c
int minSubArrayLen(int target, int* nums, int numsSize){
    int sum = 0;   // 记录总数
    int length = 0; // 记录长度
    int tmp = numsSize + 1; // 记录最小长度

    for (int i = 0; i < numsSize; ++i) {
        sum = nums[i];
        length = 1;

        for (int j = i; j < numsSize; ++j){
            sum += nums[j];
            length++;
            if (sum >= target) { // 和大于目标
                if (tmp > length) { // 长度比已记录的长度小，更新最小长度
                    tmp = length;
                }
                if (tmp = 1) { // 长度为 1 直接返回
                    return tmp;
                }
                break;
            }
        }     
    }
    if (tmp > numsSize) {
        tmp = 0;
    }
    return tmp;
}


// LeetCode 官方给的写法
int minSubArrayLen(int s, int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0;
    }
    int ans = INT_MAX;
    for (int i = 0; i < numsSize; i++) {
        int sum = 0;
        for (int j = i; j < numsSize; j++) {
            sum += nums[j];
            if (sum >= s) {
                ans = fmin(ans, j - i + 1); // math头文件(math.h)的方法
                break;
            }
        }
    }
    return ans == INT_MAX ? 0 : ans;
}

```

### 2. 前缀和 + 二分查找

时间复杂度为 O(nlogn)，需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要通过二分查找得到长度最小的子数组，二分查找的时间复杂度是 O(logn)
空间复杂度为 O(n)，创建了一个长度为 n + 1 的前缀和数组，该数组是有序的，可以用二分查找

```c
// 二分查找法查找最左边界值
int search(int* sums, int left, int right, int target) {
    if (sums[right] < target) return -1;
    while (left < right) { // left == right 会导致进入死循环
        int middle = left + ((right - left) >> 2); //防止溢出，移位运算的优先级小于加减运算的优先级，移位运算比乘除法效率高
        if (sums[middle] >= target) {
            right = middle; // 若 right = middle - 1 则有可能找不到边界值
        } else {
            left = middle + 1;
        }
    }
    return right;
}

int minSubArrayLen(int target, int* nums, int numsSize){
    int min_length = INT_MAX; // 记录最小长度
    int *sums = (int *)malloc((numsSize + 1) * sizeof(int)); // 记录前缀和的数组，sums[i] 为 nums 数组前 i 个值的和，有序数组

    // 初始化 sums
    sums[0] = 0;
    for (int i = 1; i <= numsSize; ++i) {
        sums[i] = sums[i - 1] + nums[i - 1];
    }
    // 利用 sums 求最小长度
    for (int i = 1; i <= numsSize; ++i) {
        int new_target = target + sums[i - 1]; // 在 sums 中寻找大于等于 target + sums[i - 1] 的值，因为 sums 数组的值，与从 i 开始的连续值相比，多了 sums[i - 1]
        int right = search(sums, 1, numsSize, new_target);  // 寻找最小的满足条件的下表 right
        if (right != -1) {
            min_length = fmin(min_length, right - i + 1); // // math头文件(math.h)的方法，计算长度后面需 + 1
        }
    }
    
    return min_length == INT_MAX ? 0 : min_length;  // 三元运算符，if else 的简写
}



```

### 3. 滑动窗口(双指针)

时间复杂度为 O(n)，两个指针最多各移动 n 次
空间复杂度为 O(1)

``` c
int minSubArrayLen(int target, int* nums, int numsSize){
    int min_length = INT_MAX; // 记录最小长度
    int left = 0, right = 0; // 两个指向 nums 数组的指针，都从第一个值开始
    int sum = 0; // 存储子数组的和，与 target 进行比较

    while (right < numsSize) { // 与前面两种不同的是，此处 right 与临界值比较
        sum += nums[right];  // 每次 sum 都加上 right 对应的值
        while (sum >= target) {
            min_length = fmin(min_length, right - left + 1); // 更新最小数组长度
            sum -= nums[left++]; // 减去最左边的值，并令 left + 1 ，重新寻找最小数组长度
        }
        right++; // sum 小于 target 时，right + 1 继续求和，若全部数组的和小于 target，则 min_length == INT_MAX
    }

    return min_length == INT_MAX ? 0 : min_length; // 若全部数组的和小于 target，则返回 0，否则返回最小数组长度
}
```
